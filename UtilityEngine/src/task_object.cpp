/**
* @file task_object.hpp
*
* @author Hourui (liquidmonkey)
*/

#include "task_object.hpp"

namespace Utility
{
////////////////////////////////////////////////////////////////////////////////////////////////////
namespace task
{
////////////////////////////////////////////////////////////////////////////////////////////////////
object_iface::object_iface(void)
: m_compkey({0})
, m_worker_index({0})
, m_ref({0})
{}
////////////////////////////////////////////////////////////////////////////////////////////////////
std::uint32_t 
object_iface::compkey(void)
{ 
	return m_compkey; 
}
////////////////////////////////////////////////////////////////////////////////////////////////////
bool 
object_iface::add_ref(void)
{
	std::unique_lock<std::mutex> lock(m_ref_mutex);
	if (m_ref < 0)
		return false;
	lock.unlock();

	++m_ref;
	return true;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
void object_iface::sub_ref(void)
{
	--m_ref;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
void object_iface::wait_ref(void)
{
	++m_compkey;
	std::lock_guard<std::mutex> lock(m_ref_mutex);
	int exp = 0;
	while (m_ref.compare_exchange_weak(exp, -1))
		exp = 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
void object_iface::reset_ref(void)
{
	m_ref = 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
void object_iface::set_worker_index(std::uint32_t worker)
{
	m_worker_index = worker;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
std::uint32_t object_iface::get_worker_index(void)
{
	return m_worker_index;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
}//namespace task
////////////////////////////////////////////////////////////////////////////////////////////////////
}//namespace Utility 